{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///formsy-react.js","webpack:///webpack/bootstrap 979e5107b37f1991a7cb","webpack:///./src/main.js","webpack:///./src/utils.js","webpack:///./src/Mixin.js","webpack:///./src/validationRules.js","webpack:///external \"react\""],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_4__","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","global","React","Formsy","validationRules","utils","Mixin","options","defaults","passedOptions","addValidationRule","name","func","Form","createClass","displayName","getInitialState","isValid","isSubmitting","canChange","getDefaultProps","onSuccess","onError","onSubmit","onValidSubmit","onInvalidSubmit","onSubmitted","onValid","onInvalid","onChange","validationErrors","componentWillMount","inputs","model","componentDidMount","validateForm","componentWillUpdate","inputKeys","Object","keys","setTimeout","isMounted","props","setInputValidationErrors","newInputKeys","arraysDiffer","bind","reset","setFormPristine","resetModel","submit","event","preventDefault","updateModel","mapModel","updateInputsWithError","state","mapping","forEach","component","_value","resetValue","errors","index","args","_isValid","_validationError","setState","apply","Error","JSON","stringify","_externalError","traverseChildrenAndRegisterInputs","children","Children","map","child","cloneElement","_attachToForm","attachToForm","_detachFromForm","detachFromForm","_validate","validate","_isFormDisabled","isFormDisabled","_isValidValue","value","runValidation","disabled","getCurrentValues","reduce","data","isPristine","_formSubmitted","_isPristine","validation","_isRequired","isRequired","error","currentValues","validationError","arguments","length","validationResults","runRules","_validations","requiredResults","_requiredValidations","failed","success","validations","results","validationMethod","push","allIsValid","onValidationComplete","render","DOM","form","className","a","b","isDifferent","item","isSame","objectsDiffer","key","Array","isArray","convertValidationsToObject","split","validateMethod","shift","arg","parse","e","_pristineValue","configure","setValidations","required","componentWillReceiveProps","nextProps","componentDidUpdate","prevProps","prevState","isValueChanged","setValue","componentWillUnmount","isDefaultRequiredValue","getValue","hasValue","getErrorMessage","showRequired","isFormSubmitted","showError","isValidValue","values","undefined","matchRegexp","regexp","match","isUndefined","isEmptyString","isEmail","isTrue","isFalse","isNumeric","matchResults","isAlpha","test","isWords","isSpecialWords","isLength","equals","eql","equalsField","field","maxLength","minLength"],"mappings":"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","file":"formsy-react.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Formsy\"] = factory(require(\"react\"));\n\telse\n\t\troot[\"Formsy\"] = factory(root[\"react\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_4__) {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Formsy\"] = factory(require(\"react\"));\n\telse\n\t\troot[\"Formsy\"] = factory(root[\"react\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_4__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {'use strict';\n\t\n\tvar React = global.React || __webpack_require__(4);\n\tvar Formsy = {};\n\tvar validationRules = __webpack_require__(3);\n\tvar utils = __webpack_require__(1);\n\tvar Mixin = __webpack_require__(2);\n\tvar options = {};\n\t\n\tFormsy.Mixin = Mixin;\n\t\n\tFormsy.defaults = function (passedOptions) {\n\t  options = passedOptions;\n\t};\n\t\n\tFormsy.addValidationRule = function (name, func) {\n\t  validationRules[name] = func;\n\t};\n\t\n\tFormsy.Form = React.createClass({\n\t  displayName: 'Form',\n\t\n\t  getInitialState: function getInitialState() {\n\t    return {\n\t      isValid: true,\n\t      isSubmitting: false,\n\t      canChange: false\n\t    };\n\t  },\n\t  getDefaultProps: function getDefaultProps() {\n\t    return {\n\t      onSuccess: function onSuccess() {},\n\t      onError: function onError() {},\n\t      onSubmit: function onSubmit() {},\n\t      onValidSubmit: function onValidSubmit() {},\n\t      onInvalidSubmit: function onInvalidSubmit() {},\n\t      onSubmitted: function onSubmitted() {},\n\t      onValid: function onValid() {},\n\t      onInvalid: function onInvalid() {},\n\t      onChange: function onChange() {},\n\t      validationErrors: null\n\t    };\n\t  },\n\t\n\t  // Add a map to store the inputs of the form, a model to store\n\t  // the values of the form and register child inputs\n\t  componentWillMount: function componentWillMount() {\n\t    this.inputs = {};\n\t    this.model = {};\n\t  },\n\t\n\t  componentDidMount: function componentDidMount() {\n\t    this.validateForm();\n\t  },\n\t\n\t  componentWillUpdate: function componentWillUpdate() {\n\t    var inputKeys = Object.keys(this.inputs);\n\t\n\t    // The updated children array is not available here for some reason,\n\t    // we need to wait for next event loop\n\t    setTimeout((function () {\n\t\n\t      // The component might have been unmounted on an\n\t      // update\n\t      if (this.isMounted()) {\n\t\n\t        if (this.props.validationErrors) {\n\t          this.setInputValidationErrors(this.props.validationErrors);\n\t        }\n\t\n\t        var newInputKeys = Object.keys(this.inputs);\n\t        if (utils.arraysDiffer(inputKeys, newInputKeys)) {\n\t          this.validateForm();\n\t        }\n\t      }\n\t    }).bind(this), 0);\n\t  },\n\t\n\t  reset: function reset() {\n\t    this.setFormPristine(true);\n\t    this.resetModel();\n\t  },\n\t\n\t  // Update model, submit to url prop and send the model\n\t  submit: function submit(event) {\n\t\n\t    event && event.preventDefault();\n\t\n\t    // Trigger form as not pristine.\n\t    // If any inputs have not been touched yet this will make them dirty\n\t    // so validation becomes visible (if based on isPristine)\n\t    this.setFormPristine(false);\n\t    this.updateModel();\n\t    var model = this.mapModel();\n\t    this.props.onSubmit(model, this.resetModel, this.updateInputsWithError);\n\t    this.state.isValid ? this.props.onValidSubmit(model, this.resetModel, this.updateInputsWithError) : this.props.onInvalidSubmit(model, this.resetModel, this.updateInputsWithError);\n\t  },\n\t\n\t  mapModel: function mapModel() {\n\t    return this.props.mapping ? this.props.mapping(this.model) : this.model;\n\t  },\n\t\n\t  // Goes through all registered components and\n\t  // updates the model values\n\t  updateModel: function updateModel() {\n\t    Object.keys(this.inputs).forEach((function (name) {\n\t      var component = this.inputs[name];\n\t      this.model[name] = component.state._value;\n\t    }).bind(this));\n\t  },\n\t\n\t  // Reset each key in the model to the original / initial value\n\t  resetModel: function resetModel() {\n\t    Object.keys(this.inputs).forEach((function (name) {\n\t      this.inputs[name].resetValue();\n\t    }).bind(this));\n\t    this.validateForm();\n\t  },\n\t\n\t  setInputValidationErrors: function setInputValidationErrors(errors) {\n\t    Object.keys(this.inputs).forEach((function (name, index) {\n\t      var component = this.inputs[name];\n\t      var args = [{\n\t        _isValid: !(name in errors),\n\t        _validationError: errors[name]\n\t      }];\n\t      component.setState.apply(component, args);\n\t    }).bind(this));\n\t  },\n\t\n\t  // Go through errors from server and grab the components\n\t  // stored in the inputs map. Change their state to invalid\n\t  // and set the serverError message\n\t  updateInputsWithError: function updateInputsWithError(errors) {\n\t    Object.keys(errors).forEach((function (name, index) {\n\t      var component = this.inputs[name];\n\t\n\t      if (!component) {\n\t        throw new Error('You are trying to update an input that does not exists. Verify errors object with input names. ' + JSON.stringify(errors));\n\t      }\n\t\n\t      var args = [{\n\t        _isValid: false,\n\t        _externalError: errors[name]\n\t      }];\n\t      component.setState.apply(component, args);\n\t    }).bind(this));\n\t  },\n\t\n\t  // Traverse the children and children of children to find\n\t  // all inputs by checking the name prop. Maybe do a better\n\t  // check here\n\t  traverseChildrenAndRegisterInputs: function traverseChildrenAndRegisterInputs(children) {\n\t\n\t    if (typeof children !== 'object' || children === null) {\n\t      return children;\n\t    }\n\t    return React.Children.map(children, function (child) {\n\t\n\t      if (typeof child !== 'object' || child === null) {\n\t        return child;\n\t      }\n\t\n\t      if (child.props && child.props.name) {\n\t\n\t        return React.cloneElement(child, {\n\t          _attachToForm: this.attachToForm,\n\t          _detachFromForm: this.detachFromForm,\n\t          _validate: this.validate,\n\t          _isFormDisabled: this.isFormDisabled,\n\t          _isValidValue: (function (component, value) {\n\t            return this.runValidation(component, value).isValid;\n\t          }).bind(this)\n\t        }, child.props && child.props.children);\n\t      } else {\n\t        return React.cloneElement(child, {}, this.traverseChildrenAndRegisterInputs(child.props && child.props.children));\n\t      }\n\t    }, this);\n\t  },\n\t\n\t  isFormDisabled: function isFormDisabled() {\n\t    return this.props.disabled;\n\t  },\n\t\n\t  getCurrentValues: function getCurrentValues() {\n\t    return Object.keys(this.inputs).reduce((function (data, name) {\n\t      var component = this.inputs[name];\n\t      data[name] = component.state._value;\n\t      return data;\n\t    }).bind(this), {});\n\t  },\n\t\n\t  setFormPristine: function setFormPristine(isPristine) {\n\t    var inputs = this.inputs;\n\t    var inputKeys = Object.keys(inputs);\n\t\n\t    this.setState({\n\t      _formSubmitted: !isPristine\n\t    });\n\t\n\t    // Iterate through each component and set it as pristine\n\t    // or \"dirty\".\n\t    inputKeys.forEach((function (name, index) {\n\t      var component = inputs[name];\n\t      component.setState({\n\t        _formSubmitted: !isPristine,\n\t        _isPristine: isPristine\n\t      });\n\t    }).bind(this));\n\t  },\n\t\n\t  // Use the binded values and the actual input value to\n\t  // validate the input and set its state. Then check the\n\t  // state of the form itself\n\t  validate: function validate(component) {\n\t\n\t    // Trigger onChange\n\t    if (this.state.canChange) {\n\t      this.props.onChange(this.getCurrentValues());\n\t    }\n\t\n\t    var validation = this.runValidation(component);\n\t    // Run through the validations, split them up and call\n\t    // the validator IF there is a value or it is required\n\t    component.setState({\n\t      _isValid: validation.isValid,\n\t      _isRequired: validation.isRequired,\n\t      _validationError: validation.error,\n\t      _externalError: null\n\t    }, this.validateForm);\n\t  },\n\t\n\t  // Checks validation on current value or a passed value\n\t  runValidation: function runValidation(component, value) {\n\t\n\t    var currentValues = this.getCurrentValues();\n\t    var validationErrors = component.props.validationErrors;\n\t    var validationError = component.props.validationError;\n\t    value = arguments.length === 2 ? value : component.state._value;\n\t\n\t    var validationResults = this.runRules(value, currentValues, component._validations);\n\t    var requiredResults = this.runRules(value, currentValues, component._requiredValidations);\n\t\n\t    // the component defines an explicit validate function\n\t    if (typeof component.validate === 'function') {\n\t      validationResults.failed = component.validate() ? [] : ['failed'];\n\t    }\n\t\n\t    var isRequired = Object.keys(component._requiredValidations).length ? !!requiredResults.success.length : false;\n\t    var isValid = !validationResults.failed.length && !(this.props.validationErrors && this.props.validationErrors[component.props.name]);\n\t\n\t    return {\n\t      isRequired: isRequired,\n\t      isValid: isRequired ? false : isValid,\n\t      error: (function () {\n\t\n\t        if (isValid && !isRequired) {\n\t          return '';\n\t        }\n\t\n\t        if (validationResults.errors.length) {\n\t          return validationResults.errors[0];\n\t        }\n\t\n\t        if (this.props.validationErrors && this.props.validationErrors[component.props.name]) {\n\t          return this.props.validationErrors[component.props.name];\n\t        }\n\t\n\t        if (isRequired) {\n\t          return validationErrors[requiredResults.success[0]] || null;\n\t        }\n\t\n\t        if (!isValid) {\n\t          return validationErrors[validationResults.failed[0]] || validationError;\n\t        }\n\t      }).call(this)\n\t    };\n\t  },\n\t\n\t  runRules: function runRules(value, currentValues, validations) {\n\t\n\t    var results = {\n\t      errors: [],\n\t      failed: [],\n\t      success: []\n\t    };\n\t    if (Object.keys(validations).length) {\n\t      Object.keys(validations).forEach(function (validationMethod) {\n\t\n\t        if (validationRules[validationMethod] && typeof validations[validationMethod] === 'function') {\n\t          throw new Error('Formsy does not allow you to override default validations: ' + validationMethod);\n\t        }\n\t\n\t        if (!validationRules[validationMethod] && typeof validations[validationMethod] !== 'function') {\n\t          throw new Error('Formsy does not have the validation rule: ' + validationMethod);\n\t        }\n\t\n\t        if (typeof validations[validationMethod] === 'function') {\n\t          var validation = validations[validationMethod](currentValues, value);\n\t          if (typeof validation === 'string') {\n\t            results.errors.push(validation);\n\t            results.failed.push(validationMethod);\n\t          } else if (!validation) {\n\t            results.failed.push(validationMethod);\n\t          }\n\t          return;\n\t        } else if (typeof validations[validationMethod] !== 'function') {\n\t          var validation = validationRules[validationMethod](currentValues, value, validations[validationMethod]);\n\t          if (typeof validation === 'string') {\n\t            results.errors.push(validation);\n\t            results.failed.push(validationMethod);\n\t          } else if (!validation) {\n\t            results.failed.push(validationMethod);\n\t          } else {\n\t            results.success.push(validationMethod);\n\t          }\n\t          return;\n\t        }\n\t\n\t        return results.success.push(validationMethod);\n\t      });\n\t    }\n\t\n\t    return results;\n\t  },\n\t\n\t  // Validate the form by going through all child input components\n\t  // and check their state\n\t  validateForm: function validateForm() {\n\t    var allIsValid = true;\n\t    var inputs = this.inputs;\n\t    var inputKeys = Object.keys(inputs);\n\t\n\t    // We need a callback as we are validating all inputs again. This will\n\t    // run when the last component has set its state\n\t    var onValidationComplete = (function () {\n\t      inputKeys.forEach((function (name) {\n\t        if (!inputs[name].state._isValid) {\n\t          allIsValid = false;\n\t        }\n\t      }).bind(this));\n\t\n\t      this.setState({\n\t        isValid: allIsValid\n\t      });\n\t\n\t      if (allIsValid) {\n\t        this.props.onValid();\n\t      } else {\n\t        this.props.onInvalid();\n\t      }\n\t\n\t      // Tell the form that it can start to trigger change events\n\t      this.setState({\n\t        canChange: true\n\t      });\n\t    }).bind(this);\n\t\n\t    // Run validation again in case affected by other inputs. The\n\t    // last component validated will run the onValidationComplete callback\n\t    inputKeys.forEach((function (name, index) {\n\t      var component = inputs[name];\n\t      var validation = this.runValidation(component);\n\t      if (validation.isValid && component.state._externalError) {\n\t        validation.isValid = false;\n\t      }\n\t      component.setState({\n\t        _isValid: validation.isValid,\n\t        _isRequired: validation.isRequired,\n\t        _validationError: validation.error,\n\t        _externalError: !validation.isValid && component.state._externalError ? component.state._externalError : null\n\t      }, index === inputKeys.length - 1 ? onValidationComplete : null);\n\t    }).bind(this));\n\t\n\t    // If there are no inputs, set state where form is ready to trigger\n\t    // change event. New inputs might be added later\n\t    if (!inputKeys.length && this.isMounted()) {\n\t      this.setState({\n\t        canChange: true\n\t      });\n\t    }\n\t  },\n\t\n\t  // Method put on each input component to register\n\t  // itself to the form\n\t  attachToForm: function attachToForm(component) {\n\t    this.inputs[component.props.name] = component;\n\t    this.model[component.props.name] = component.state._value;\n\t    this.validate(component);\n\t  },\n\t\n\t  // Method put on each input component to unregister\n\t  // itself from the form\n\t  detachFromForm: function detachFromForm(component) {\n\t    delete this.inputs[component.props.name];\n\t    delete this.model[component.props.name];\n\t  },\n\t  render: function render() {\n\t\n\t    return React.DOM.form({\n\t      onSubmit: this.submit,\n\t      className: this.props.className\n\t    }, this.traverseChildrenAndRegisterInputs(this.props.children));\n\t  }\n\t});\n\t\n\tif (!global.exports && !global.module && (!global.define || !global.define.amd)) {\n\t  global.Formsy = Formsy;\n\t}\n\t\n\tmodule.exports = Formsy;\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tmodule.exports = {\n\t  arraysDiffer: function arraysDiffer(a, b) {\n\t    var isDifferent = false;\n\t    if (a.length !== b.length) {\n\t      isDifferent = true;\n\t    } else {\n\t      a.forEach(function (item, index) {\n\t        if (!this.isSame(item, b[index])) {\n\t          isDifferent = true;\n\t        }\n\t      }, this);\n\t    }\n\t    return isDifferent;\n\t  },\n\t  objectsDiffer: function objectsDiffer(a, b) {\n\t    var isDifferent = false;\n\t    if (Object.keys(a).length !== Object.keys(b).length) {\n\t      isDifferent = true;\n\t    } else {\n\t      Object.keys(a).forEach(function (key) {\n\t        if (!this.isSame(a[key], b[key])) {\n\t          isDifferent = true;\n\t        }\n\t      }, this);\n\t    }\n\t    return isDifferent;\n\t  },\n\t  isSame: function isSame(a, b) {\n\t\n\t    if (a !== b) {\n\t      return false;\n\t    }\n\t\n\t    if (Array.isArray(a)) {\n\t      return !this.arraysDiffer(a, b);\n\t    } else if (typeof a === 'object' && a !== null) {\n\t      return !this.objectsDiffer(a, b);\n\t    }\n\t\n\t    return true;\n\t  }\n\t};\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar utils = __webpack_require__(1);\n\t\n\tvar convertValidationsToObject = function convertValidationsToObject(validations) {\n\t\n\t  if (typeof validations === 'string') {\n\t\n\t    return validations.split(/\\,(?![^{\\[]*[}\\]])/g).reduce(function (validations, validation) {\n\t      var args = validation.split(':');\n\t      var validateMethod = args.shift();\n\t\n\t      args = args.map(function (arg) {\n\t        try {\n\t          return JSON.parse(arg);\n\t        } catch (e) {\n\t          return arg; // It is a string if it can not parse it\n\t        }\n\t      });\n\t\n\t      if (args.length > 1) {\n\t        throw new Error('Formsy does not support multiple args on string validations. Use object format of validations instead.');\n\t      }\n\t\n\t      validations[validateMethod] = args.length ? args[0] : true;\n\t      return validations;\n\t    }, {});\n\t  }\n\t\n\t  return validations || {};\n\t};\n\t\n\tmodule.exports = {\n\t  getInitialState: function getInitialState() {\n\t    return {\n\t      _value: this.props.value,\n\t      _isRequired: false,\n\t      _isValid: true,\n\t      _isPristine: true,\n\t      _pristineValue: this.props.value,\n\t      _validationError: '',\n\t      _externalError: null,\n\t      _formSubmitted: false\n\t    };\n\t  },\n\t  getDefaultProps: function getDefaultProps() {\n\t    return {\n\t      validationError: '',\n\t      validationErrors: {}\n\t    };\n\t  },\n\t\n\t  componentWillMount: function componentWillMount() {\n\t    var configure = (function () {\n\t      this.setValidations(this.props.validations, this.props.required);\n\t      this.props._attachToForm(this);\n\t    }).bind(this);\n\t\n\t    if (!this.props.name) {\n\t      throw new Error('Form Input requires a name property when used');\n\t    }\n\t\n\t    if (!this.props._attachToForm) {\n\t      return setTimeout((function () {\n\t        if (!this.isMounted()) return;\n\t        if (!this.props._attachToForm) {\n\t          throw new Error('Form Mixin requires component to be nested in a Form');\n\t        }\n\t        configure();\n\t      }).bind(this), 0);\n\t    }\n\t    configure();\n\t  },\n\t\n\t  // We have to make the validate method is kept when new props are added\n\t  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {\n\t    this.setValidations(nextProps.validations, nextProps.required);\n\t  },\n\t\n\t  componentDidUpdate: function componentDidUpdate(prevProps, prevState) {\n\t\n\t    var isValueChanged = (function () {\n\t\n\t      return !utils.isSame(this.props.value, prevProps.value) && utils.isSame(this.state._value, prevProps.value);\n\t    }).bind(this);\n\t\n\t    // If validations has changed or something outside changes\n\t    // the value, set the value again running a validation\n\t    if (isValueChanged()) {\n\t      this.setValue(this.props.value);\n\t    }\n\t  },\n\t\n\t  // Detach it when component unmounts\n\t  componentWillUnmount: function componentWillUnmount() {\n\t    this.props._detachFromForm(this);\n\t  },\n\t\n\t  setValidations: function setValidations(validations, required) {\n\t\n\t    // Add validations to the store itself as the props object can not be modified\n\t    this._validations = convertValidationsToObject(validations) || {};\n\t    this._requiredValidations = required === true ? { isDefaultRequiredValue: true } : convertValidationsToObject(required);\n\t  },\n\t\n\t  // We validate after the value has been set\n\t  setValue: function setValue(value) {\n\t    this.setState({\n\t      _value: value,\n\t      _isPristine: false\n\t    }, (function () {\n\t      this.props._validate(this);\n\t    }).bind(this));\n\t  },\n\t  resetValue: function resetValue() {\n\t    this.setState({\n\t      _value: this.state._pristineValue,\n\t      _isPristine: true\n\t    }, function () {\n\t      this.props._validate(this);\n\t    });\n\t  },\n\t  getValue: function getValue() {\n\t    return this.state._value;\n\t  },\n\t  hasValue: function hasValue() {\n\t    return this.state._value !== '';\n\t  },\n\t  getErrorMessage: function getErrorMessage() {\n\t    return !this.isValid() || this.showRequired() ? this.state._externalError || this.state._validationError : null;\n\t  },\n\t  isFormDisabled: function isFormDisabled() {\n\t    return this.props._isFormDisabled();\n\t  },\n\t  isValid: function isValid() {\n\t    return this.state._isValid;\n\t  },\n\t  isPristine: function isPristine() {\n\t    return this.state._isPristine;\n\t  },\n\t  isFormSubmitted: function isFormSubmitted() {\n\t    return this.state._formSubmitted;\n\t  },\n\t  isRequired: function isRequired() {\n\t    return !!this.props.required;\n\t  },\n\t  showRequired: function showRequired() {\n\t    return this.state._isRequired;\n\t  },\n\t  showError: function showError() {\n\t    return !this.showRequired() && !this.isValid();\n\t  },\n\t  isValidValue: function isValidValue(value) {\n\t    return this.props._isValidValue.call(null, this, value);\n\t  }\n\t};\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tmodule.exports = {\n\t  isDefaultRequiredValue: function isDefaultRequiredValue(values, value) {\n\t    return value === undefined || value === '';\n\t  },\n\t  hasValue: function hasValue(values, value) {\n\t    return !!value;\n\t  },\n\t  matchRegexp: function matchRegexp(values, value, regexp) {\n\t    return !!value && !!value.match(regexp);\n\t  },\n\t  isUndefined: function isUndefined(values, value) {\n\t    return value === undefined;\n\t  },\n\t  isEmptyString: function isEmptyString(values, value) {\n\t    return value === '';\n\t  },\n\t  isEmail: function isEmail(values, value) {\n\t    return !value || value.match(/^((([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+(\\.([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+)*)|((\\x22)((((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(([\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]|\\x21|[\\x23-\\x5b]|[\\x5d-\\x7e]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(\\\\([\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))))*(((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(\\x22)))@((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))$/i);\n\t  },\n\t  isTrue: function isTrue(values, value) {\n\t    return value === true;\n\t  },\n\t  isFalse: function isFalse(values, value) {\n\t    return value === false;\n\t  },\n\t  isNumeric: function isNumeric(values, value) {\n\t    if (!value) {\n\t      return false;\n\t    }\n\t    if (typeof value === 'number') {\n\t      return true;\n\t    } else {\n\t      var matchResults = value.match(/[-+]?(\\d*[.])?\\d+/);\n\t      if (!!matchResults) {\n\t        return matchResults[0] == value;\n\t      } else {\n\t        return false;\n\t      }\n\t    }\n\t  },\n\t  isAlpha: function isAlpha(values, value) {\n\t    return value && /^[a-zA-Z]+$/.test(value);\n\t  },\n\t  isWords: function isWords(values, value) {\n\t    return value && /^[a-zA-Z\\s]+$/.test(value);\n\t  },\n\t  isSpecialWords: function isSpecialWords(values, value) {\n\t    return !value || value.match(/^[a-zA-Z\\s\\u00C0-\\u017F]+$/);\n\t  },\n\t  isLength: function isLength(values, value, length) {\n\t    return value && value.length === length;\n\t  },\n\t  equals: function equals(values, value, eql) {\n\t    return value == eql;\n\t  },\n\t  equalsField: function equalsField(values, value, field) {\n\t    return value == values[field];\n\t  },\n\t  maxLength: function maxLength(values, value, length) {\n\t    return value && value.length && value.length <= length;\n\t  },\n\t  minLength: function minLength(values, value, length) {\n\t    return value && value.length && value.length >= length;\n\t  }\n\t};\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_4__;\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** formsy-react.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 979e5107b37f1991a7cb\n **/","var React = global.React || require('react');\nvar Formsy = {};\nvar validationRules = require('./validationRules.js');\nvar utils = require('./utils.js');\nvar Mixin = require('./Mixin.js');\nvar options = {};\n\nFormsy.Mixin = Mixin;\n\nFormsy.defaults = function (passedOptions) {\n  options = passedOptions;\n};\n\nFormsy.addValidationRule = function (name, func) {\n  validationRules[name] = func;\n};\n\nFormsy.Form = React.createClass({\n  getInitialState: function () {\n    return {\n      isValid: true,\n      isSubmitting: false,\n      canChange: false\n    };\n  },\n  getDefaultProps: function () {\n    return {\n      onSuccess: function () {},\n      onError: function () {},\n      onSubmit: function () {},\n      onValidSubmit: function () {},\n      onInvalidSubmit: function () {},\n      onSubmitted: function () {},\n      onValid: function () {},\n      onInvalid: function () {},\n      onChange: function () {},\n      validationErrors: null\n    };\n  },\n\n  // Add a map to store the inputs of the form, a model to store\n  // the values of the form and register child inputs\n  componentWillMount: function () {\n    this.inputs = {};\n    this.model = {};\n  },\n\n  componentDidMount: function () {\n    this.validateForm();\n  },\n\n  componentWillUpdate: function () {\n    var inputKeys = Object.keys(this.inputs);\n\n    // The updated children array is not available here for some reason,\n    // we need to wait for next event loop\n    setTimeout(function () {\n\n      // The component might have been unmounted on an\n      // update\n      if (this.isMounted()) {\n\n        if (this.props.validationErrors) {\n          this.setInputValidationErrors(this.props.validationErrors);\n        }\n\n        var newInputKeys = Object.keys(this.inputs);\n        if (utils.arraysDiffer(inputKeys, newInputKeys)) {\n          this.validateForm();\n        }\n\n      }\n\n    }.bind(this), 0);\n  },\n\n  reset: function () {\n    this.setFormPristine(true);\n    this.resetModel();\n  },\n\n  // Update model, submit to url prop and send the model\n  submit: function (event) {\n\n    event && event.preventDefault();\n\n    // Trigger form as not pristine.\n    // If any inputs have not been touched yet this will make them dirty\n    // so validation becomes visible (if based on isPristine)\n    this.setFormPristine(false);\n    this.updateModel();\n    var model = this.mapModel();\n    this.props.onSubmit(model, this.resetModel, this.updateInputsWithError);\n    this.state.isValid ? this.props.onValidSubmit(model, this.resetModel, this.updateInputsWithError) : this.props.onInvalidSubmit(model, this.resetModel, this.updateInputsWithError);\n\n  },\n\n  mapModel: function () {\n    return this.props.mapping ? this.props.mapping(this.model) : this.model;\n  },\n\n  // Goes through all registered components and\n  // updates the model values\n  updateModel: function () {\n    Object.keys(this.inputs).forEach(function (name) {\n      var component = this.inputs[name];\n      this.model[name] = component.state._value;\n    }.bind(this));\n  },\n\n  // Reset each key in the model to the original / initial value\n  resetModel: function () {\n    Object.keys(this.inputs).forEach(function (name) {\n      this.inputs[name].resetValue();\n    }.bind(this));\n    this.validateForm();\n  },\n\n  setInputValidationErrors: function (errors) {\n    Object.keys(this.inputs).forEach(function (name, index) {\n      var component = this.inputs[name];\n      var args = [{\n        _isValid: !(name in errors),\n        _validationError: errors[name]\n      }];\n      component.setState.apply(component, args);\n    }.bind(this));\n  },\n\n  // Go through errors from server and grab the components\n  // stored in the inputs map. Change their state to invalid\n  // and set the serverError message\n  updateInputsWithError: function (errors) {\n    Object.keys(errors).forEach(function (name, index) {\n      var component = this.inputs[name];\n\n      if (!component) {\n        throw new Error('You are trying to update an input that does not exists. Verify errors object with input names. ' + JSON.stringify(errors));\n      }\n\n      var args = [{\n        _isValid: false,\n        _externalError: errors[name]\n      }];\n      component.setState.apply(component, args);\n    }.bind(this));\n  },\n\n  // Traverse the children and children of children to find\n  // all inputs by checking the name prop. Maybe do a better\n  // check here\n  traverseChildrenAndRegisterInputs: function (children) {\n\n    if (typeof children !== 'object' || children === null) {\n      return children;\n    }\n    return React.Children.map(children, function (child) {\n\n      if (typeof child !== 'object' || child === null) {\n        return child;\n      }\n\n      if (child.props && child.props.name) {\n\n        return React.cloneElement(child, {\n          _attachToForm: this.attachToForm,\n          _detachFromForm: this.detachFromForm,\n          _validate: this.validate,\n          _isFormDisabled: this.isFormDisabled,\n          _isValidValue: function (component, value) {\n            return this.runValidation(component, value).isValid;\n          }.bind(this)\n        }, child.props && child.props.children);\n      } else {\n        return React.cloneElement(child, {}, this.traverseChildrenAndRegisterInputs(child.props && child.props.children));\n      }\n\n    }, this);\n\n  },\n\n  isFormDisabled: function () {\n    return this.props.disabled;\n  },\n\n  getCurrentValues: function () {\n    return Object.keys(this.inputs).reduce(function (data, name) {\n      var component = this.inputs[name];\n      data[name] = component.state._value;\n      return data;\n    }.bind(this), {});\n  },\n\n  setFormPristine: function (isPristine) {\n    var inputs = this.inputs;\n    var inputKeys = Object.keys(inputs);\n\n    this.setState({\n        _formSubmitted: !isPristine\n    })\n\n    // Iterate through each component and set it as pristine\n    // or \"dirty\".\n    inputKeys.forEach(function (name, index) {\n      var component = inputs[name];\n      component.setState({\n        _formSubmitted: !isPristine,\n        _isPristine: isPristine\n      });\n    }.bind(this));\n  },\n\n  // Use the binded values and the actual input value to\n  // validate the input and set its state. Then check the\n  // state of the form itself\n  validate: function (component) {\n\n    // Trigger onChange\n    if (this.state.canChange) {\n      this.props.onChange(this.getCurrentValues());\n    }\n\n    var validation = this.runValidation(component);\n    // Run through the validations, split them up and call\n    // the validator IF there is a value or it is required\n    component.setState({\n      _isValid: validation.isValid,\n      _isRequired: validation.isRequired,\n      _validationError: validation.error,\n      _externalError: null\n    }, this.validateForm);\n\n  },\n\n  // Checks validation on current value or a passed value\n  runValidation: function (component, value) {\n\n    var currentValues = this.getCurrentValues();\n    var validationErrors = component.props.validationErrors;\n    var validationError = component.props.validationError;\n    value = arguments.length === 2 ? value : component.state._value;\n\n    var validationResults = this.runRules(value, currentValues, component._validations);\n    var requiredResults = this.runRules(value, currentValues, component._requiredValidations);\n\n    // the component defines an explicit validate function\n    if (typeof component.validate === \"function\") {\n      validationResults.failed = component.validate() ? [] : ['failed'];\n    }\n\n    var isRequired = Object.keys(component._requiredValidations).length ? !!requiredResults.success.length : false;\n    var isValid = !validationResults.failed.length && !(this.props.validationErrors && this.props.validationErrors[component.props.name]);\n\n    return {\n      isRequired: isRequired,\n      isValid: isRequired ? false : isValid,\n      error: (function () {\n\n        if (isValid && !isRequired) {\n          return '';\n        }\n\n        if (validationResults.errors.length) {\n          return validationResults.errors[0];\n        }\n\n        if (this.props.validationErrors && this.props.validationErrors[component.props.name]) {\n          return this.props.validationErrors[component.props.name];\n        }\n\n        if (isRequired) {\n          return validationErrors[requiredResults.success[0]] || null;\n        }\n\n        if (!isValid) {\n          return validationErrors[validationResults.failed[0]] || validationError;\n        }\n\n      }.call(this))\n    };\n\n  },\n\n  runRules: function (value, currentValues, validations) {\n\n    var results = {\n      errors: [],\n      failed: [],\n      success: []\n    };\n    if (Object.keys(validations).length) {\n      Object.keys(validations).forEach(function (validationMethod) {\n\n        if (validationRules[validationMethod] && typeof validations[validationMethod] === 'function') {\n          throw new Error('Formsy does not allow you to override default validations: ' + validationMethod);\n        }\n\n        if (!validationRules[validationMethod] && typeof validations[validationMethod] !== 'function') {\n          throw new Error('Formsy does not have the validation rule: ' + validationMethod);\n        }\n\n        if (typeof validations[validationMethod] === 'function') {\n          var validation = validations[validationMethod](currentValues, value);\n          if (typeof validation === 'string') {\n            results.errors.push(validation);\n            results.failed.push(validationMethod);\n          } else if (!validation) {\n            results.failed.push(validationMethod);\n          }\n          return;\n\n        } else if (typeof validations[validationMethod] !== 'function') {\n          var validation = validationRules[validationMethod](currentValues, value, validations[validationMethod]);\n          if (typeof validation === 'string') {\n            results.errors.push(validation);\n            results.failed.push(validationMethod);\n          } else if (!validation) {\n            results.failed.push(validationMethod);\n          } else {\n            results.success.push(validationMethod);\n          }\n          return;\n\n        }\n\n        return results.success.push(validationMethod);\n\n      });\n    }\n\n    return results;\n\n  },\n\n  // Validate the form by going through all child input components\n  // and check their state\n  validateForm: function () {\n    var allIsValid = true;\n    var inputs = this.inputs;\n    var inputKeys = Object.keys(inputs);\n\n    // We need a callback as we are validating all inputs again. This will\n    // run when the last component has set its state\n    var onValidationComplete = function () {\n      inputKeys.forEach(function (name) {\n        if (!inputs[name].state._isValid) {\n          allIsValid = false;\n        }\n      }.bind(this));\n\n      this.setState({\n        isValid: allIsValid\n      });\n\n      if (allIsValid) {\n        this.props.onValid();\n      } else {\n        this.props.onInvalid();\n      }\n\n      // Tell the form that it can start to trigger change events\n      this.setState({\n        canChange: true\n      });\n\n    }.bind(this);\n\n    // Run validation again in case affected by other inputs. The\n    // last component validated will run the onValidationComplete callback\n    inputKeys.forEach(function (name, index) {\n      var component = inputs[name];\n      var validation = this.runValidation(component);\n      if (validation.isValid && component.state._externalError) {\n        validation.isValid = false;\n      }\n      component.setState({\n        _isValid: validation.isValid,\n        _isRequired: validation.isRequired,\n        _validationError: validation.error,\n        _externalError: !validation.isValid && component.state._externalError ? component.state._externalError : null\n      }, index === inputKeys.length - 1 ? onValidationComplete : null);\n    }.bind(this));\n\n    // If there are no inputs, set state where form is ready to trigger\n    // change event. New inputs might be added later\n    if (!inputKeys.length && this.isMounted()) {\n      this.setState({\n        canChange: true\n      });\n    }\n  },\n\n  // Method put on each input component to register\n  // itself to the form\n  attachToForm: function (component) {\n    this.inputs[component.props.name] = component;\n    this.model[component.props.name] = component.state._value;\n    this.validate(component);\n  },\n\n  // Method put on each input component to unregister\n  // itself from the form\n  detachFromForm: function (component) {\n    delete this.inputs[component.props.name];\n    delete this.model[component.props.name];\n  },\n  render: function () {\n\n    return React.DOM.form({\n        onSubmit: this.submit,\n        className: this.props.className\n      },\n      this.traverseChildrenAndRegisterInputs(this.props.children)\n    );\n\n  }\n});\n\nif (!global.exports && !global.module && (!global.define || !global.define.amd)) {\n  global.Formsy = Formsy;\n}\n\nmodule.exports = Formsy;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/main.js\n **/","module.exports = {\n  arraysDiffer: function (a, b) {\n    var isDifferent = false;\n    if (a.length !== b.length) {\n      isDifferent = true;\n    } else {\n      a.forEach(function (item, index) {\n        if (!this.isSame(item, b[index])) {\n          isDifferent = true;\n        }\n      }, this);\n    }\n    return isDifferent;\n  },\n  objectsDiffer: function (a, b) {\n    var isDifferent = false;\n    if (Object.keys(a).length !== Object.keys(b).length) {\n      isDifferent = true;\n    } else {\n      Object.keys(a).forEach(function (key) {\n        if (!this.isSame(a[key], b[key])) {\n          isDifferent = true;\n        }\n      }, this);\n    }\n    return isDifferent;   \n  },\n  isSame: function (a, b) {\n    \n    if (a !== b) {\n      return false;\n    }\n\n    if (Array.isArray(a)) {\n      return !this.arraysDiffer(a, b);\n    } else if (typeof a === 'object' && a !== null) {\n      return !this.objectsDiffer(a, b);\n    }\n\n    return true;\n  }\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/utils.js\n **/","var utils = require('./utils.js');\n\nvar convertValidationsToObject = function (validations) {\n\n  if (typeof validations === 'string') {\n\n    return validations.split(/\\,(?![^{\\[]*[}\\]])/g).reduce(function (validations, validation) {\n      var args = validation.split(':');\n      var validateMethod = args.shift();\n\n      args = args.map(function (arg) {\n        try {\n          return JSON.parse(arg);\n        } catch (e) {\n          return arg; // It is a string if it can not parse it\n        }\n      });\n\n      if (args.length > 1) {\n        throw new Error('Formsy does not support multiple args on string validations. Use object format of validations instead.');\n      }\n\n      validations[validateMethod] = args.length ? args[0] : true;\n      return validations;\n    }, {});\n\n  }\n\n  return validations || {};\n};\n\nmodule.exports = {\n  getInitialState: function () {\n    return {\n      _value: this.props.value,\n      _isRequired: false,\n      _isValid: true,\n      _isPristine: true,\n      _pristineValue: this.props.value,\n      _validationError: '',\n      _externalError: null,\n      _formSubmitted: false\n    };\n  },\n  getDefaultProps: function () {\n    return {\n      validationError: '',\n      validationErrors: {}\n    };\n  },\n\n  componentWillMount: function () {\n    var configure = function () {\n      this.setValidations(this.props.validations, this.props.required);\n      this.props._attachToForm(this);\n    }.bind(this);\n\n    if (!this.props.name) {\n      throw new Error('Form Input requires a name property when used');\n    }\n\n    if (!this.props._attachToForm) {\n      return setTimeout(function () {\n        if (!this.isMounted()) return;\n        if (!this.props._attachToForm) {\n          throw new Error('Form Mixin requires component to be nested in a Form');\n        }\n        configure();\n      }.bind(this), 0);\n    }\n    configure();\n  },\n\n  // We have to make the validate method is kept when new props are added\n  componentWillReceiveProps: function (nextProps) {\n    this.setValidations(nextProps.validations, nextProps.required);\n  },\n\n  componentDidUpdate: function (prevProps, prevState) {\n\n    var isValueChanged = function () {\n\n      return !utils.isSame(this.props.value, prevProps.value) && utils.isSame(this.state._value, prevProps.value);\n\n    }.bind(this);\n\n    // If validations has changed or something outside changes\n    // the value, set the value again running a validation\n    if (isValueChanged()) {\n      this.setValue(this.props.value);\n    }\n  },\n\n  // Detach it when component unmounts\n  componentWillUnmount: function () {\n    this.props._detachFromForm(this);\n  },\n\n  setValidations: function (validations, required) {\n\n    // Add validations to the store itself as the props object can not be modified\n    this._validations = convertValidationsToObject(validations) || {};\n    this._requiredValidations = required === true ? {isDefaultRequiredValue: true} : convertValidationsToObject(required);\n\n  },\n\n  // We validate after the value has been set\n  setValue: function (value) {\n    this.setState({\n      _value: value,\n      _isPristine: false\n    }, function () {\n      this.props._validate(this);\n    }.bind(this));\n  },\n  resetValue: function () {\n    this.setState({\n      _value: this.state._pristineValue,\n      _isPristine: true\n    }, function () {\n      this.props._validate(this);\n    });\n  },\n  getValue: function () {\n    return this.state._value;\n  },\n  hasValue: function () {\n    return this.state._value !== '';\n  },\n  getErrorMessage: function () {\n    return !this.isValid() || this.showRequired() ? (this.state._externalError || this.state._validationError) : null;\n  },\n  isFormDisabled: function () {\n    return this.props._isFormDisabled();\n  },\n  isValid: function () {\n    return this.state._isValid;\n  },\n  isPristine: function () {\n    return this.state._isPristine;\n  },\n  isFormSubmitted: function () {\n    return this.state._formSubmitted;\n  },\n  isRequired: function () {\n    return !!this.props.required;\n  },\n  showRequired: function () {\n    return this.state._isRequired;\n  },\n  showError: function () {\n    return !this.showRequired() && !this.isValid();\n  },\n  isValidValue: function (value) {\n    return this.props._isValidValue.call(null, this, value);\n  }\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/Mixin.js\n **/","module.exports = {\n  isDefaultRequiredValue: function (values, value) {\n    return value === undefined || value === '';\n  },\n  hasValue: function (values, value) {\n    return !!value;\n  },\n  matchRegexp: function (values, value, regexp) {\n    return !!value && !!value.match(regexp);\n  },\n  isUndefined: function (values, value) {\n    return value === undefined;\n  },\n  isEmptyString: function (values, value) {\n    return value === '';\n  },\n  isEmail: function (values, value) {\n    return !value || value.match(/^((([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+(\\.([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+)*)|((\\x22)((((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(([\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]|\\x21|[\\x23-\\x5b]|[\\x5d-\\x7e]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(\\\\([\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))))*(((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(\\x22)))@((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))$/i);\n  },\n  isTrue: function (values, value) {\n    return value === true;\n  },\n  isFalse: function (values, value) {\n    return value === false;\n  },\n  isNumeric: function (values, value) {\n    if (!value) {\n        return false;\n    }\n    if (typeof value === 'number') {\n      return true;\n    } else {\n      var matchResults = value.match(/[-+]?(\\d*[.])?\\d+/);\n      if (!!matchResults) {\n        return matchResults[0] == value;\n      } else {\n        return false;\n      }\n    }\n  },\n  isAlpha: function (values, value) {\n    return value && /^[a-zA-Z]+$/.test(value);\n  },\n  isWords: function (values, value) {\n    return value && /^[a-zA-Z\\s]+$/.test(value);\n  },\n  isSpecialWords: function (values, value) {\n    return !value || value.match(/^[a-zA-Z\\s\\u00C0-\\u017F]+$/);\n  },\n  isLength: function (values, value, length) {\n    return value && value.length === length;\n  },\n  equals: function (values, value, eql) {\n    return value == eql;\n  },\n  equalsField: function (values, value, field) {\n    return value == values[field];\n  },\n  maxLength: function (values, value, length) {\n    return value && value.length && value.length <= length;\n  },\n  minLength: function (values, value, length) {\n    return value && value.length && value.length >= length;\n  }\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/validationRules.js\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_4__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"react\"\n ** module id = 4\n ** module chunks = 0\n **/"],"sourceRoot":""}